## 2024-05-22 - GlobalScope in Worker Helpers **Learning:** Helper classes used by `CoroutineWorker` (like `LibraryUpdateNotifier`) sometimes use `GlobalScope` to "fire and forget" UI updates, but this decouples the work from the Worker's lifecycle. Making these helpers `suspend` ensures the Worker stays alive until notifications are processed. **Action:** When refactoring helpers called by Workers, prefer `suspend` functions over `GlobalScope` to bind execution to the Worker's `doWork` scope.

## 2024-05-23 - Default Dispatcher Injection **Learning:** The project lacks centralized DI for CoroutineDispatchers in `AppModule.kt`. Refactoring concurrency requires injecting Dispatchers as constructor parameters with default values (e.g., `val ioDispatcher: CoroutineDispatcher = Dispatchers.IO`) to maintain compatibility with `Injekt`'s factory methods while enabling testability. **Action:** Use default parameter values for Dispatcher injection instead of modifying the global DI graph unless a Dispatcher module is introduced.
